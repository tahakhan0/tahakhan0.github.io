{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Hi \ud83d\udc4b, I'm Taha Khan. I work as a backend engineer at Octopus Energy and I'm currently a team lead for the Octopus Energy USA API team. I usually blog about things that I've learned and found interesting to be shared. I follow three main principles (according to me): Get a working demo as soon as possible. All the blogs/youtube tutorials can come later. Always be a student. Appreciate, forgive, and be kind to team members of all levels. Recent posts \u00b6 Match bool prefix Findings when I had to implement Elastic Search. Python datetimes (part-1) A good deep-dive into a bug and learning quirks about datetimes. GraphQL interfaces How I find them and would recommend using them.","title":"Home"},{"location":"#home","text":"Hi \ud83d\udc4b, I'm Taha Khan. I work as a backend engineer at Octopus Energy and I'm currently a team lead for the Octopus Energy USA API team. I usually blog about things that I've learned and found interesting to be shared. I follow three main principles (according to me): Get a working demo as soon as possible. All the blogs/youtube tutorials can come later. Always be a student. Appreciate, forgive, and be kind to team members of all levels.","title":"Home"},{"location":"#recent-posts","text":"Match bool prefix Findings when I had to implement Elastic Search. Python datetimes (part-1) A good deep-dive into a bug and learning quirks about datetimes. GraphQL interfaces How I find them and would recommend using them.","title":"Recent posts"},{"location":"CLI%20using%20Typer/","text":"Background \u00b6 I was given a task to write a cli (command line interface) tool in python. Naively, I started with argparse . Which is an awesome library but not beginner friendly. Luckily my mentor/manager stopped me at the right time and introduced me to Typer . Typer is a library written by Sebasti\u00e1n Ram\u00edrez and it makes it really easy to write CLI tools. It is simple and easy to learn because it lets you write python functions using Typer's decorators. Meaning you can write CLI tools if you know basic python functions. Project \u00b6 I'm going to explain what I've learned by creating a CLI tool that parses a CSV file obtained from National Records of Scotland here . It contains ~4000 records with first_name, last_name, number, rank, and sex. Link to git repo here The repo contains extensive documentation on how to run commands and what to expect by each of it. However with this post, I will be breaking down the how's/what's/when's of the commands. For example: Let's take the first command, read . \u00b6 It is a python function that uses a decorator with some inputs. @app . command () def read ( path : Path = typer . Argument ( None )): \"\"\" 1. Name of the command: read 2. Inputs a. path: Description: Required input (therefore Argument). By default set to None. Type: Path Short version: N/A \"\"\" Usage: $ cd src python main . py read ../ babies_names . csv Now, the second command, find . \u00b6 @app . command () def find ( path : Path = typer . Argument ( None ), fields : Optional [ List [ str ]] = typer . Option ( None , \"--f\" ), write_path : Path = typer . Option ( None , \"--w\" ), ): \"\"\" 1. Name of the command: find 2. Inputs a. path: Description: Required input (therefore Argument). By default set to None. Type: Path Short version: N/A b. fields: Description: An optional list of strings. By default set to None. Type: List of strings. Short version: --f c. write_path: Description: Optional input (therefore Argument). By default set to None. Type: Path Short version: --w \"\"\" Usage: $ cd src python main . py find ../ babies_names . csv -- f year -- f sex -- w ../ write_new_file . csv That should be more than enough to get you started. For an in-depth explanation please take a look at the repo . If you have any questions/comments/suggestions reach out to me via twitter","title":"Writing CLI tools using Typer"},{"location":"CLI%20using%20Typer/#background","text":"I was given a task to write a cli (command line interface) tool in python. Naively, I started with argparse . Which is an awesome library but not beginner friendly. Luckily my mentor/manager stopped me at the right time and introduced me to Typer . Typer is a library written by Sebasti\u00e1n Ram\u00edrez and it makes it really easy to write CLI tools. It is simple and easy to learn because it lets you write python functions using Typer's decorators. Meaning you can write CLI tools if you know basic python functions.","title":"Background"},{"location":"CLI%20using%20Typer/#project","text":"I'm going to explain what I've learned by creating a CLI tool that parses a CSV file obtained from National Records of Scotland here . It contains ~4000 records with first_name, last_name, number, rank, and sex. Link to git repo here The repo contains extensive documentation on how to run commands and what to expect by each of it. However with this post, I will be breaking down the how's/what's/when's of the commands. For example:","title":"Project"},{"location":"CLI%20using%20Typer/#lets-take-the-first-command-read","text":"It is a python function that uses a decorator with some inputs. @app . command () def read ( path : Path = typer . Argument ( None )): \"\"\" 1. Name of the command: read 2. Inputs a. path: Description: Required input (therefore Argument). By default set to None. Type: Path Short version: N/A \"\"\" Usage: $ cd src python main . py read ../ babies_names . csv","title":"Let's take the first command, read."},{"location":"CLI%20using%20Typer/#now-the-second-command-find","text":"@app . command () def find ( path : Path = typer . Argument ( None ), fields : Optional [ List [ str ]] = typer . Option ( None , \"--f\" ), write_path : Path = typer . Option ( None , \"--w\" ), ): \"\"\" 1. Name of the command: find 2. Inputs a. path: Description: Required input (therefore Argument). By default set to None. Type: Path Short version: N/A b. fields: Description: An optional list of strings. By default set to None. Type: List of strings. Short version: --f c. write_path: Description: Optional input (therefore Argument). By default set to None. Type: Path Short version: --w \"\"\" Usage: $ cd src python main . py find ../ babies_names . csv -- f year -- f sex -- w ../ write_new_file . csv That should be more than enough to get you started. For an in-depth explanation please take a look at the repo . If you have any questions/comments/suggestions reach out to me via twitter","title":"Now, the second command, find."},{"location":"Elastic-Search/","text":"Background \u00b6 One of the best things about my work place ( Octopus Energy ) is that I get to learn new tools and have the luxury to try and fail. Earlier this year, I was given a task to implement elastic search for a model that is heavily used by our customers. The real challenge was to improve lookups, but for me, it was learning elastic search and doing it right the first time. I strongly believe learning becomes easier when I can understand what needs to be learned. The diffcult part is finding out what to learn and how to apply. Fortunately, I found some previous PRs by my colleagues and the best part was concise commits and PR structure they maintained. I just had to figure out how to put in the exact same structure and make it work in my case. Side note - One of the best arts I've picked at Octopus Energy is that I absolutely love chronlogical commits, PR descriptions that try to solve one problem and do it thoroughly. My PR descriptions will also contain enough notes to help the next person get started on a similar work. I also do it out of selfishness because I don't usually get it right the first time, so it is easier for me to just look back again and have all the commands and resources available. What was my problem? \u00b6 I already got over the big part which was understanding and implementing elastic search. However, it wasn't being used in the way I thought it would be used. I mean, I thought users would always search using the perfect search terms, they would always have the right spellings or they won't try to search using a keyword in the middle of a sentence. Turns out I was all wrong. It wasn't the user's fault, it was my thinking of how this service would be used. Answer \u00b6 Get feedback from your users and try to use the service as they would use. One of the pain points that was immediately obvious was that I totally forgot the importance of combining search results to narrow down a search. In other words, I simply forgot how to do an \"AND\" search. This reminds me of my ECE 251 class at NJIT and my professor's famous quote: Don't lose common sense . Solution \u00b6 Perform an \"AND\" search and combine it's result with a match_bool_prefix search. For example: import elasticsearch_dsl as es def get_concise_results (): parent = \"Some input that should be used for an exact match\" child = \"Some input that can be fuzzy\" parent_query = es . Q ( \"match\" , parent = parent ) child_query = es . Q ( \"match_bool_prefix\" , child = child ) s = Search ( index = \"some_index\" ) . query ( parent_query ) . query ( child_query ) return s . exectue () By doing an \"AND\" search, which is simply calling the query function twice, I already improved my results by a very far margin. Then comes match_bool_prefix , which allows fuzzy match but also supports prefix query. Which means users could search by something in the middle of a sentence and still get results, or if they tried to lookup using the keywords at the start of the sentence, they would still get much better results. If you use Kibana (highly recommended) to perform elastic search queries here's the query: { \"query\": { \"bool\" : { \"match\": { parent_field:\"parent_query\" }, \"match_bool_prefix\":{ child_field: \"child_query\" } ] } } } References \u00b6 If you've made this far, I would highly recommend to read through our coding conventions Match bool prefix ( link to Elastic Search docs )","title":"Elastic Search (part 1 of many)"},{"location":"Elastic-Search/#background","text":"One of the best things about my work place ( Octopus Energy ) is that I get to learn new tools and have the luxury to try and fail. Earlier this year, I was given a task to implement elastic search for a model that is heavily used by our customers. The real challenge was to improve lookups, but for me, it was learning elastic search and doing it right the first time. I strongly believe learning becomes easier when I can understand what needs to be learned. The diffcult part is finding out what to learn and how to apply. Fortunately, I found some previous PRs by my colleagues and the best part was concise commits and PR structure they maintained. I just had to figure out how to put in the exact same structure and make it work in my case. Side note - One of the best arts I've picked at Octopus Energy is that I absolutely love chronlogical commits, PR descriptions that try to solve one problem and do it thoroughly. My PR descriptions will also contain enough notes to help the next person get started on a similar work. I also do it out of selfishness because I don't usually get it right the first time, so it is easier for me to just look back again and have all the commands and resources available.","title":"Background"},{"location":"Elastic-Search/#what-was-my-problem","text":"I already got over the big part which was understanding and implementing elastic search. However, it wasn't being used in the way I thought it would be used. I mean, I thought users would always search using the perfect search terms, they would always have the right spellings or they won't try to search using a keyword in the middle of a sentence. Turns out I was all wrong. It wasn't the user's fault, it was my thinking of how this service would be used.","title":"What was my problem?"},{"location":"Elastic-Search/#answer","text":"Get feedback from your users and try to use the service as they would use. One of the pain points that was immediately obvious was that I totally forgot the importance of combining search results to narrow down a search. In other words, I simply forgot how to do an \"AND\" search. This reminds me of my ECE 251 class at NJIT and my professor's famous quote: Don't lose common sense .","title":"Answer"},{"location":"Elastic-Search/#solution","text":"Perform an \"AND\" search and combine it's result with a match_bool_prefix search. For example: import elasticsearch_dsl as es def get_concise_results (): parent = \"Some input that should be used for an exact match\" child = \"Some input that can be fuzzy\" parent_query = es . Q ( \"match\" , parent = parent ) child_query = es . Q ( \"match_bool_prefix\" , child = child ) s = Search ( index = \"some_index\" ) . query ( parent_query ) . query ( child_query ) return s . exectue () By doing an \"AND\" search, which is simply calling the query function twice, I already improved my results by a very far margin. Then comes match_bool_prefix , which allows fuzzy match but also supports prefix query. Which means users could search by something in the middle of a sentence and still get results, or if they tried to lookup using the keywords at the start of the sentence, they would still get much better results. If you use Kibana (highly recommended) to perform elastic search queries here's the query: { \"query\": { \"bool\" : { \"match\": { parent_field:\"parent_query\" }, \"match_bool_prefix\":{ child_field: \"child_query\" } ] } } }","title":"Solution"},{"location":"Elastic-Search/#references","text":"If you've made this far, I would highly recommend to read through our coding conventions Match bool prefix ( link to Elastic Search docs )","title":"References"},{"location":"GraphQL-Interfaces/","text":"Also known as abstraction, mixin, base classes. Although, I like the word interface because it reminds me of its similarity with an electric socket, that needs something to be plugged into it to be useful. In the image below, we can see the behavior of an interface (socket). It merely provides power to the objects nothing more. If the objects are powered using a battery, then we don't even need the interface (socket) except for charging the batteries, but you get the idea. Usage \u00b6 The big picture is you need an interface if one or more objects share a common way to operate. BUT don't overuse it. Just because you have a socket doesn't mean you don't check the voltage, shape of the plug, or electric bill. You have to be cautious. Key difference \u00b6 Often missed in explanations is that interfaces are meant to be used for returning object types. Meaning if you want to use them to create/update data don't use interfaces. Go with creating a base class in your preferred language. How to use interfaces (in queries/reading data)? \u00b6 Let's say we want to build an API for the housing market. Note : examples are using graphene which is a python library. And, again interfaces are meant to return data and not create data. types.py \u00b6 import graphene class PropertyInterface ( graphene . Interface ): \"\"\" A generic base class that all property types should implement. \"\"\" property_type = graphene . String ( description = \"Condo/Apartment/Duplex.\" ) rooms = graphene . Int ( description = \"Number of rooms available.\" ) garage = graphene . Boolean ( description = \"Does the property have a garage?\" , default_value = False ) class DownTownPropertyType ( graphene . ObjectType ): \"\"\" This type will implement properties in the downtown area. \"\"\" class Meta : interfaces = ( PropertyInterface ,) near_by_restaurant = graphene . String () schema.py \u00b6 import graphene from . import types class Query ( graphene . ObjectType ): get_down_town_property = graphene . Field ( types . DownTownPropertyType ) schema = graphene . Schema ( query = Query ) GraphiQL viewer \u00b6 Using the viewer we can take a look at the get_down_town_property query: This means when we query get_down_town_property we have access to the interface fields as well. query getDowntownProperty { getDownTownProperty { propertyType # Inherited from interface rooms # Inherited from interface garage # Inherited from interface nearByRestaurant } } We will use \u261d\ufe0f type in a mutation that is created \u2b07\ufe0f Using a base class as an interface in mutations. \u00b6 types.py \u00b6 # Here we are using graphene.InputObjectType instead of graphene.Interface. class PropertyInputBase ( graphene . InputObjectType ): \"\"\" A generic base class that all input objects should implement. \"\"\" property_type = graphene . String ( description = \"Condo/Apartment/Duplex.\" ) rooms = graphene . Int ( description = \"Number of rooms available.\" ) garage = graphene . Boolean ( description = \"Does the property have a garage?\" , default_value = False ) # Inherit the PropertyInputBase (aka interface, aka base class) class DownTownInputType ( PropertyInputBase , graphene . InputObjectType ): near_by_restaurant = graphene . String () schema.py \u00b6 class CreateDowntownProperty ( graphene . Mutation ): class Arguments : input = types . DownTownInputType () # Output type of the data. # Note: We are using graphene.ObjectType that uses an interface. downtown_property = graphene . Field ( types . DownTownPropertyType ) def mutate ( root , info , input ): return CreateDowntownProperty ( downtown_property = input ) class Mutation ( graphene . ObjectType ): create_downtown_property = CreateDowntownProperty . Field () schema = graphene . Schema ( mutation = Mutation ) Below is a screenshot that shows the flow of mutation. Here we have an input which uses the DownTownInputType that uses a shared base class. Whereas the output is of type DownTownPropertyType which uses an interface created above. We can call the mutation from the GraphiQL viewer in the following way: Resources \u00b6 There are some great examples mentioned in the Production Ready Graphql which is a book written by Marc-Andr\u00e9 Giroux . Graphene documentation . The API team at my work Octopus Energy . If you have any questions or comments reach out to me via twitter","title":"GraphQL Interface"},{"location":"GraphQL-Interfaces/#usage","text":"The big picture is you need an interface if one or more objects share a common way to operate. BUT don't overuse it. Just because you have a socket doesn't mean you don't check the voltage, shape of the plug, or electric bill. You have to be cautious.","title":"Usage"},{"location":"GraphQL-Interfaces/#key-difference","text":"Often missed in explanations is that interfaces are meant to be used for returning object types. Meaning if you want to use them to create/update data don't use interfaces. Go with creating a base class in your preferred language.","title":"Key difference"},{"location":"GraphQL-Interfaces/#how-to-use-interfaces-in-queriesreading-data","text":"Let's say we want to build an API for the housing market. Note : examples are using graphene which is a python library. And, again interfaces are meant to return data and not create data.","title":"How to use interfaces (in queries/reading data)?"},{"location":"GraphQL-Interfaces/#typespy","text":"import graphene class PropertyInterface ( graphene . Interface ): \"\"\" A generic base class that all property types should implement. \"\"\" property_type = graphene . String ( description = \"Condo/Apartment/Duplex.\" ) rooms = graphene . Int ( description = \"Number of rooms available.\" ) garage = graphene . Boolean ( description = \"Does the property have a garage?\" , default_value = False ) class DownTownPropertyType ( graphene . ObjectType ): \"\"\" This type will implement properties in the downtown area. \"\"\" class Meta : interfaces = ( PropertyInterface ,) near_by_restaurant = graphene . String ()","title":"types.py"},{"location":"GraphQL-Interfaces/#schemapy","text":"import graphene from . import types class Query ( graphene . ObjectType ): get_down_town_property = graphene . Field ( types . DownTownPropertyType ) schema = graphene . Schema ( query = Query )","title":"schema.py"},{"location":"GraphQL-Interfaces/#graphiql-viewer","text":"Using the viewer we can take a look at the get_down_town_property query: This means when we query get_down_town_property we have access to the interface fields as well. query getDowntownProperty { getDownTownProperty { propertyType # Inherited from interface rooms # Inherited from interface garage # Inherited from interface nearByRestaurant } } We will use \u261d\ufe0f type in a mutation that is created \u2b07\ufe0f","title":"GraphiQL viewer"},{"location":"GraphQL-Interfaces/#using-a-base-class-as-an-interface-in-mutations","text":"","title":"Using a base class as an interface in mutations."},{"location":"GraphQL-Interfaces/#typespy_1","text":"# Here we are using graphene.InputObjectType instead of graphene.Interface. class PropertyInputBase ( graphene . InputObjectType ): \"\"\" A generic base class that all input objects should implement. \"\"\" property_type = graphene . String ( description = \"Condo/Apartment/Duplex.\" ) rooms = graphene . Int ( description = \"Number of rooms available.\" ) garage = graphene . Boolean ( description = \"Does the property have a garage?\" , default_value = False ) # Inherit the PropertyInputBase (aka interface, aka base class) class DownTownInputType ( PropertyInputBase , graphene . InputObjectType ): near_by_restaurant = graphene . String ()","title":"types.py"},{"location":"GraphQL-Interfaces/#schemapy_1","text":"class CreateDowntownProperty ( graphene . Mutation ): class Arguments : input = types . DownTownInputType () # Output type of the data. # Note: We are using graphene.ObjectType that uses an interface. downtown_property = graphene . Field ( types . DownTownPropertyType ) def mutate ( root , info , input ): return CreateDowntownProperty ( downtown_property = input ) class Mutation ( graphene . ObjectType ): create_downtown_property = CreateDowntownProperty . Field () schema = graphene . Schema ( mutation = Mutation ) Below is a screenshot that shows the flow of mutation. Here we have an input which uses the DownTownInputType that uses a shared base class. Whereas the output is of type DownTownPropertyType which uses an interface created above. We can call the mutation from the GraphiQL viewer in the following way:","title":"schema.py"},{"location":"GraphQL-Interfaces/#resources","text":"There are some great examples mentioned in the Production Ready Graphql which is a book written by Marc-Andr\u00e9 Giroux . Graphene documentation . The API team at my work Octopus Energy . If you have any questions or comments reach out to me via twitter","title":"Resources"},{"location":"Python-Datetime-Part-1/","text":"Background \u00b6 This week I was tackling a bug that involved datetime and timezones. After working on it for a while I needed help. Not necessarily a hard problem but timezones are confusing and can quickly make the problem worse. Luckily at my work, Octopus Energy , we've great team members that are always there to help. And David Seddon offerred to help. David, if you're reading this blog, Thank you \ud83d\ude4f You should check out his blog , he has some intereseting topics there. What was my problem? \u00b6 If a given datetime is in UTC, will it still be the same if we convert it to central timezone (America/Chicago)? Answer \u00b6 Yes it will be. In David's words (paraphrasing): Two datetimes will be equal to each other if they are in the same moment. That threw me off \ud83e\udd2f But after spending some time and really undestanding what he meant, it finally clicked. UTC : Is a time standard by which we represent a particular instance of time globally. So basically if a timezone let's say \"X\" is represented in UTC, it means \"X\" is expressed in a positive or negative offset from UTC ( from wikipedia ). For example: CENTRAL_TIMEZONE = pytz . timezone ( \"America/Chicago\" ) def compare_utc_and_central () -> bool : central_datetime = datetime ( 2021 , 10 , 5 , tzinfo = CENTRAL_TIMEZONE ) utc_datetime = central_datetime . astimezone ( timezone . utc ) print ( central_datetime ) # prints: 2021-10-05 00:00:00-05:51 print ( utc_datetime ) # prints: 2021-10-05 05:51:00+00:00 return central_datetime == utc_datetime # Returns True Another example: Let's say you have a UTC datetime and you want to convert it into a central timezone, but this time without calling the astimezone . Also useful if you've tests and want to assert at specific time. import freezegun import pytz from datetime import date , datetime , timezone from typing import Tuple def get_central_datetime_using_utc_datetime ( utc_datetime : datetime ) -> bool : \"\"\" Notice the usage of freezegun. We have to make sure that we are in the same moment and freezegun allows us to do that. \"\"\" with freezegun . freeze_time ( utc_datetime ): central_datetime = datetime . now ( tz = CENTRAL_TIMEZONE ) return central_datetime == utc_datetime # Returns True In summary, this was a great learning experience for me. And because of David, I can say that I somewhat have an understanding of timezones in python. Not all obviously, hence the title of this blog is Part 1 of many. There's still a lot to learn.","title":"Python datetime (Part 1 of many)"},{"location":"Python-Datetime-Part-1/#background","text":"This week I was tackling a bug that involved datetime and timezones. After working on it for a while I needed help. Not necessarily a hard problem but timezones are confusing and can quickly make the problem worse. Luckily at my work, Octopus Energy , we've great team members that are always there to help. And David Seddon offerred to help. David, if you're reading this blog, Thank you \ud83d\ude4f You should check out his blog , he has some intereseting topics there.","title":"Background"},{"location":"Python-Datetime-Part-1/#what-was-my-problem","text":"If a given datetime is in UTC, will it still be the same if we convert it to central timezone (America/Chicago)?","title":"What was my problem?"},{"location":"Python-Datetime-Part-1/#answer","text":"Yes it will be. In David's words (paraphrasing): Two datetimes will be equal to each other if they are in the same moment. That threw me off \ud83e\udd2f But after spending some time and really undestanding what he meant, it finally clicked. UTC : Is a time standard by which we represent a particular instance of time globally. So basically if a timezone let's say \"X\" is represented in UTC, it means \"X\" is expressed in a positive or negative offset from UTC ( from wikipedia ). For example: CENTRAL_TIMEZONE = pytz . timezone ( \"America/Chicago\" ) def compare_utc_and_central () -> bool : central_datetime = datetime ( 2021 , 10 , 5 , tzinfo = CENTRAL_TIMEZONE ) utc_datetime = central_datetime . astimezone ( timezone . utc ) print ( central_datetime ) # prints: 2021-10-05 00:00:00-05:51 print ( utc_datetime ) # prints: 2021-10-05 05:51:00+00:00 return central_datetime == utc_datetime # Returns True Another example: Let's say you have a UTC datetime and you want to convert it into a central timezone, but this time without calling the astimezone . Also useful if you've tests and want to assert at specific time. import freezegun import pytz from datetime import date , datetime , timezone from typing import Tuple def get_central_datetime_using_utc_datetime ( utc_datetime : datetime ) -> bool : \"\"\" Notice the usage of freezegun. We have to make sure that we are in the same moment and freezegun allows us to do that. \"\"\" with freezegun . freeze_time ( utc_datetime ): central_datetime = datetime . now ( tz = CENTRAL_TIMEZONE ) return central_datetime == utc_datetime # Returns True In summary, this was a great learning experience for me. And because of David, I can say that I somewhat have an understanding of timezones in python. Not all obviously, hence the title of this blog is Part 1 of many. There's still a lot to learn.","title":"Answer"}]}